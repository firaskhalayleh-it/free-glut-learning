<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FreeGLUT Learning Platform</title>
    <!-- Meta Tags for Responsiveness -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrQkTyHJ9bgFKtAvf+6hb+6U3cLTBOGxR9ZKYf7qM6BOAAyfCnWm3+TmlkBSVByCFYcQjR+ER7NjaVprCg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/dracula.min.css">
    <!-- CSS Styles -->
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f4f4f4;
            color: #333;
            line-height: 1.6;
        }
        a {
            text-decoration: none;
            color: inherit;
        }
        /* Navigation Bar */
        .navbar {
            background-color: #333;
            color: #fff;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        .navbar .logo {
            font-size: 1.5em;
            font-weight: bold;
        }
        .navbar ul {
            list-style: none;
            display: flex;
        }
        .navbar ul li {
            margin-left: 20px;
        }
        .navbar ul li a {
            color: #fff;
            transition: color 0.3s ease;
        }
        .navbar ul li a:hover {
            color: #f4f4f4;
        }
        .menu-toggle {
            display: none;
            font-size: 1.5em;
            cursor: pointer;
        }
        /* Hero Section */
        .hero {
            background: url('https://images.unsplash.com/photo-1518770660439-4636190af475?auto=format&fit=crop&w=1350&q=80') no-repeat center center/cover;
            height: 60vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .hero::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
        }
        .hero-content {
            position: relative;
            color: #fff;
            text-align: center;
            max-width: 800px;
        }
        .hero-content h1 {
            font-size: 3em;
            margin-bottom: 20px;
        }
        .hero-content p {
            font-size: 1.2em;
            margin-bottom: 30px;
        }
        .hero-content .btn {
            background-color: #ff5722;
            color: #fff;
            padding: 15px 30px;
            border: none;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            border-radius: 5px;
        }
        .hero-content .btn:hover {
            background-color: #e64a19;
        }
        /* Main Content */
        .container {
            padding: 40px 20px;
            max-width: 1200px;
            margin: auto;
        }
        /* Tutorials Section */
        .tutorials {
            margin-bottom: 60px;
        }
        .tutorials h2 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5em;
            color: #333;
        }
        .tutorial {
            background-color: #fff;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 5px solid #ff5722;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border-radius: 5px;
        }
        .tutorial h3 {
            margin-bottom: 15px;
            color: #ff5722;
        }
        .tutorial p {
            margin-bottom: 15px;
        }
        .tutorial pre {
            background-color: #2d2d2d;
            padding: 15px;
            overflow-x: auto;
            border-radius: 5px;
            color: #f8f8f2;
        }
        .tutorial code {
            color: #f8f8f2;
        }
        /* Quizzes Section */
        .quizzes {
            margin-bottom: 60px;
        }
        .quizzes h2 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5em;
            color: #333;
        }
        .quiz {
            background-color: #fff;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 5px solid #2196f3;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border-radius: 5px;
        }
        .quiz h3 {
            margin-bottom: 15px;
            color: #2196f3;
        }
        .quiz .options {
            list-style: none;
            padding: 0;
        }
        .quiz .options li {
            margin-bottom: 10px;
        }
        .quiz .options li label {
            cursor: pointer;
        }
        .quiz .btn-submit {
            background-color: #2196f3;
            color: #fff;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 10px;
            border-radius: 5px;
        }
        .quiz .btn-submit:hover {
            background-color: #1976d2;
        }
        .quiz .result {
            margin-top: 15px;
            font-weight: bold;
        }
        /* Code Editor Section */
        .code-editor-section {
            margin-bottom: 60px;
        }
        .code-editor-section h2 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5em;
            color: #333;
        }
        .editor-container {
            background-color: #fff;
            padding: 20px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border-radius: 5px;
        }
        .editor-container .CodeMirror {
            height: 300px;
        }
        .editor-container .btn-run {
            background-color: #4caf50;
            color: #fff;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 10px;
            border-radius: 5px;
        }
        .editor-container .btn-run:hover {
            background-color: #388e3c;
        }
        .editor-container .output {
            background-color: #f0f0f0;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            min-height: 100px;
            white-space: pre-wrap;
        }
        /* 3D Visualization Section */
        .visualization-section {
            margin-bottom: 60px;
        }
        .visualization-section h2 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5em;
            color: #333;
        }
        .visualization-container {
            background-color: #fff;
            padding: 20px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border-radius: 5px;
            text-align: center;
        }
        .visualization-container canvas {
            border: 1px solid #ccc;
            margin-top: 20px;
        }
        /* Progress Tracker */
        .progress-tracker {
            margin-bottom: 60px;
        }
        .progress-tracker h2 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 2.5em;
            color: #333;
        }
        .progress-bar {
            background-color: #ddd;
            border-radius: 25px;
            overflow: hidden;
            margin: 20px 0;
        }
        .progress-bar-inner {
            height: 30px;
            width: 0;
            background-color: #ff5722;
            text-align: center;
            line-height: 30px;
            color: #fff;
            transition: width 0.5s ease;
            border-radius: 25px;
        }
        /* Footer */
        .footer {
            background-color: #333;
            color: #fff;
            padding: 20px 0;
            text-align: center;
        }
        .footer p {
            margin-bottom: 10px;
        }
        .footer .social-icons a {
            color: #fff;
            margin: 0 10px;
            font-size: 1.2em;
            transition: color 0.3s ease;
        }
        .footer .social-icons a:hover {
            color: #ff5722;
        }
        /* Responsive Design */
        @media (max-width: 768px) {
            .navbar ul {
                flex-direction: column;
                background-color: #444;
                position: absolute;
                top: 60px;
                right: 0;
                width: 200px;
                display: none;
            }
            .navbar ul li {
                margin: 15px 0;
                text-align: center;
            }
            .navbar .menu-toggle {
                display: block;
                cursor: pointer;
            }
            .navbar.active ul {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="logo">FreeGLUT Learn</div>
        <div class="menu-toggle"><i class="fas fa-bars"></i></div>
        <ul>
            <li><a href="#tutorials">Tutorials</a></li>
            <li><a href="#quizzes">Quizzes</a></li>
            <li><a href="#code-editor">Code Editor</a></li>
            <li><a href="#visualization">Visualization</a></li>
            <li><a href="#progress">Progress</a></li>
            <li><a href="#footer">Contact</a></li>
        </ul>
    </nav>

    <!-- Hero Section -->
    <section class="hero">
        <div class="hero-content">
            <h1>Master FreeGLUT</h1>
            <p>Learn FreeGLUT step by step with interactive tutorials, quizzes, and coding practice.</p>
            <button class="btn" onclick="scrollToSection('tutorials')">Start Learning</button>
        </div>
    </section>

    <!-- Main Container -->
    <div class="container">
        <!-- Tutorials Section -->
        <section id="tutorials" class="tutorials">
            <h2>Tutorials</h2>
            <!-- Tutorial 1 -->
            <div class="tutorial" data-tutorial-id="1">
                <h3>1. Introduction to FreeGLUT</h3>
                <p>FreeGLUT is an open-source alternative to the OpenGL Utility Toolkit (GLUT) library. It provides a simple API for creating windows, handling input, and managing the OpenGL context.</p>
                <p><strong>Key Features:</strong></p>
                <ul>
                    <li>Window creation and management</li>
                    <li>Input handling (keyboard, mouse)</li>
                    <li>Callback functions for rendering and events</li>
                </ul>
                <pre><code>#include <GL/freeglut.h>

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutCreateWindow("FreeGLUT Window");
    glutMainLoop();
    return 0;
}</code></pre>
                <button class="btn-submit" onclick="completeTutorial(1)">Mark as Completed</button>
                <div class="result" id="result-tutorial1"></div>
            </div>
            <!-- Tutorial 2 -->
            <div class="tutorial" data-tutorial-id="2">
                <h3>2. Setting Up Code::Blocks with FreeGLUT</h3>
                <p>Follow these steps to set up FreeGLUT in Code::Blocks:</p>
                <ol>
                    <li><strong>Download FreeGLUT:</strong> Visit the <a href="https://sourceforge.net/projects/freeglut/" target="_blank">FreeGLUT SourceForge page</a> and download the latest version.</li>
                    <li><strong>Extract Files:</strong> Extract the downloaded files to a directory, e.g., <code>C:\FreeGLUT</code>.</li>
                    <li><strong>Configure Code::Blocks:</strong>
                        <ul>
                            <li>Open Code::Blocks and create a new project.</li>
                            <li>Go to <strong>Project > Build options</strong>.</li>
                            <li>Add the FreeGLUT <code>include</code> directory in the Compiler settings.</li>
                            <li>Add the FreeGLUT <code>lib</code> directory in the Linker settings.</li>
                            <li>Link against <code>freeglut.lib</code>, <code>opengl32.lib</code>, <code>glu32.lib</code>, and <code>gdi32.lib</code>.</li>
                        </ul>
                    </li>
                </ol>
                <pre><code>// Example Code::Blocks Configuration
// Compiler Settings > Search directories > Compiler: C:\FreeGLUT\include
// Linker Settings > Search directories > Linker: C:\FreeGLUT\lib
// Linker Settings > Link libraries: freeglut.lib; opengl32.lib; glu32.lib; gdi32.lib</code></pre>
                <button class="btn-submit" onclick="completeTutorial(2)">Mark as Completed</button>
                <div class="result" id="result-tutorial2"></div>
            </div>
            <!-- Tutorial 3 -->
            <div class="tutorial" data-tutorial-id="3">
                <h3>3. Basic OpenGL Rendering with FreeGLUT</h3>
                <p>Learn how to render a simple triangle using FreeGLUT and OpenGL.</p>
                <pre><code>#include <GL/freeglut.h>

// Rotation angle
float angle = 0.0f;

// Display callback
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    // Rotate the triangle
    glRotatef(angle, 0.0f, 1.0f, 0.0f);

    // Draw a colored triangle
    glBegin(GL_TRIANGLES);
        glColor3f(1.0f, 0.0f, 0.0f); // Red
        glVertex3f(-0.5f, -0.5f, 0.0f);
        
        glColor3f(0.0f, 1.0f, 0.0f); // Green
        glVertex3f(0.5f, -0.5f, 0.0f);
        
        glColor3f(0.0f, 0.0f, 1.0f); // Blue
        glVertex3f(0.0f, 0.5f, 0.0f);
    glEnd();

    glutSwapBuffers();
}

// Idle callback for animation
void idle() {
    angle += 0.1f;
    if (angle > 360.0f)
        angle -= 360.0f;
    glutPostRedisplay();
}

// Initialize OpenGL settings
void initGL() {
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
}

// Main function
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    // Use double buffering and RGB colors with depth buffer
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    // Set window size
    glutInitWindowSize(800, 600);
    // Create window with title
    glutCreateWindow("FreeGLUT Rotating Triangle");

    initGL();

    // Register callbacks
    glutDisplayFunc(display);
    glutIdleFunc(idle);

    // Enter the main loop
    glutMainLoop();
    return 0;
}</code></pre>
                <button class="btn-submit" onclick="completeTutorial(3)">Mark as Completed</button>
                <div class="result" id="result-tutorial3"></div>
            </div>
            <!-- Tutorial 4 -->
            <div class="tutorial" data-tutorial-id="4">
                <h3>4. Handling Keyboard and Mouse Input</h3>
                <p>Learn how to handle user input using FreeGLUT's callback functions.</p>
                <pre><code>#include <GL/freeglut.h>

// Rotation angle
float angle = 0.0f;

// Display callback
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    // Rotate the triangle
    glRotatef(angle, 0.0f, 1.0f, 0.0f);

    // Draw a colored triangle
    glBegin(GL_TRIANGLES);
        glColor3f(1.0f, 0.0f, 0.0f); // Red
        glVertex3f(-0.5f, -0.5f, 0.0f);
        
        glColor3f(0.0f, 1.0f, 0.0f); // Green
        glVertex3f(0.5f, -0.5f, 0.0f);
        
        glColor3f(0.0f, 0.0f, 1.0f); // Blue
        glVertex3f(0.0f, 0.5f, 0.0f);
    glEnd();

    glutSwapBuffers();
}

// Idle callback for animation
void idle() {
    angle += 0.1f;
    if (angle > 360.0f)
        angle -= 360.0f;
    glutPostRedisplay();
}

// Keyboard callback
void handleKeypress(unsigned char key, int x, int y) {
    switch(key) {
        case 27: // ESC key
            exit(0);
            break;
        case 'r': // Reset rotation
            angle = 0.0f;
            break;
    }
}

// Mouse callback
void handleMouse(int button, int state, int x, int y) {
    if(button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        angle += 10.0f;
    }
}

// Initialize OpenGL settings
void initGL() {
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
}

// Main function
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    // Use double buffering and RGB colors with depth buffer
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    // Set window size
    glutInitWindowSize(800, 600);
    // Create window with title
    glutCreateWindow("FreeGLUT Input Handling");

    initGL();

    // Register callbacks
    glutDisplayFunc(display);
    glutIdleFunc(idle);
    glutKeyboardFunc(handleKeypress);
    glutMouseFunc(handleMouse);

    // Enter the main loop
    glutMainLoop();
    return 0;
}</code></pre>
                <button class="btn-submit" onclick="completeTutorial(4)">Mark as Completed</button>
                <div class="result" id="result-tutorial4"></div>
            </div>
            <!-- Tutorial 5 -->
            <div class="tutorial" data-tutorial-id="5">
                <h3>5. Animations and Timers</h3>
                <p>Implement animations using FreeGLUT's timer functions.</p>
                <pre><code>#include <GL/freeglut.h>

// Rotation angle
float angle = 0.0f;

// Display callback
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    // Rotate the triangle
    glRotatef(angle, 0.0f, 1.0f, 0.0f);

    // Draw a colored triangle
    glBegin(GL_TRIANGLES);
        glColor3f(1.0f, 0.0f, 0.0f); // Red
        glVertex3f(-0.5f, -0.5f, 0.0f);
        
        glColor3f(0.0f, 1.0f, 0.0f); // Green
        glVertex3f(0.5f, -0.5f, 0.0f);
        
        glColor3f(0.0f, 0.0f, 1.0f); // Blue
        glVertex3f(0.0f, 0.5f, 0.0f);
    glEnd();

    glutSwapBuffers();
}

// Timer callback for animation
void timer(int value) {
    angle += 1.0f;
    if (angle > 360.0f)
        angle -= 360.0f;
    glutPostRedisplay();
    glutTimerFunc(16, timer, 0); // Approximately 60 FPS
}

// Initialize OpenGL settings
void initGL() {
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
}

// Main function
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    // Use double buffering and RGB colors with depth buffer
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    // Set window size
    glutInitWindowSize(800, 600);
    // Create window with title
    glutCreateWindow("FreeGLUT Animation");

    initGL();

    // Register callbacks
    glutDisplayFunc(display);
    glutTimerFunc(0, timer, 0);

    // Enter the main loop
    glutMainLoop();
    return 0;
}</code></pre>
                <button class="btn-submit" onclick="completeTutorial(5)">Mark as Completed</button>
                <div class="result" id="result-tutorial5"></div>
            </div>
            <!-- Tutorial 6 -->
            <div class="tutorial" data-tutorial-id="6">
                <h3>6. 3D Rendering with FreeGLUT</h3>
                <p>Extend your knowledge to render 3D objects using FreeGLUT and OpenGL.</p>
                <pre><code>#include <GL/freeglut.h>

// Rotation angles
float angleX = 0.0f;
float angleY = 0.0f;

// Display callback
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    // Move back to see the cube
    glTranslatef(0.0f, 0.0f, -5.0f);

    // Rotate the cube
    glRotatef(angleX, 1.0f, 0.0f, 0.0f);
    glRotatef(angleY, 0.0f, 1.0f, 0.0f);

    // Draw a cube
    glutSolidCube(2.0f);

    glutSwapBuffers();
}

// Idle callback for animation
void idle() {
    angleX += 0.3f;
    angleY += 0.2f;
    if (angleX > 360.0f)
        angleX -= 360.0f;
    if (angleY > 360.0f)
        angleY -= 360.0f;
    glutPostRedisplay();
}

// Initialize OpenGL settings
void initGL() {
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glEnable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
}

// Main function
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    // Use double buffering, RGB colors, and depth buffer
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    // Set window size
    glutInitWindowSize(800, 600);
    // Create window with title
    glutCreateWindow("FreeGLUT 3D Cube");

    initGL();

    // Register callbacks
    glutDisplayFunc(display);
    glutIdleFunc(idle);

    // Set light properties
    GLfloat light_pos[] = {1.0f, 1.0f, 1.0f, 0.0f};
    glLightfv(GL_LIGHT0, GL_POSITION, light_pos);

    // Enter the main loop
    glutMainLoop();
    return 0;
}</code></pre>
                <button class="btn-submit" onclick="completeTutorial(6)">Mark as Completed</button>
                <div class="result" id="result-tutorial6"></div>
            </div>
            <!-- Tutorial 7 -->
            <div class="tutorial" data-tutorial-id="7">
                <h3>7. Lighting and Shading</h3>
                <p>Implement basic lighting and shading to enhance the visual appearance of your 3D objects.</p>
                <pre><code>#include <GL/freeglut.h>

// Rotation angles
float angleX = 0.0f;
float angleY = 0.0f;

// Display callback
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    // Move back to see the cube
    glTranslatef(0.0f, 0.0f, -7.0f);

    // Rotate the cube
    glRotatef(angleX, 1.0f, 0.0f, 0.0f);
    glRotatef(angleY, 0.0f, 1.0f, 0.0f);

    // Set material properties
    GLfloat mat_specular[] = {1.0, 1.0, 1.0, 1.0};
    GLfloat mat_shininess[] = {50.0};
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    // Draw a cube
    glutSolidCube(2.0f);

    glutSwapBuffers();
}

// Idle callback for animation
void idle() {
    angleX += 0.3f;
    angleY += 0.2f;
    if (angleX > 360.0f)
        angleX -= 360.0f;
    if (angleY > 360.0f)
        angleY -= 360.0f;
    glutPostRedisplay();
}

// Initialize OpenGL settings
void initGL() {
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    // Light properties
    GLfloat light_ambient[]  = { 0.2f, 0.2f, 0.2f, 1.0f };
    GLfloat light_diffuse[]  = { 0.8f, 0.8f, 0.8f, 1.0f };
    GLfloat light_specular[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    GLfloat light_position[] = { 1.0f, 1.0f, 1.0f, 0.0f };

    glLightfv(GL_LIGHT0, GL_AMBIENT,  light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE,  light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
}

// Main function
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    // Use double buffering, RGB colors, and depth buffer
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    // Set window size
    glutInitWindowSize(800, 600);
    // Create window with title
    glutCreateWindow("FreeGLUT Lighting and Shading");

    initGL();

    // Register callbacks
    glutDisplayFunc(display);
    glutIdleFunc(idle);

    // Enter the main loop
    glutMainLoop();
    return 0;
}</code></pre>
                <button class="btn-submit" onclick="completeTutorial(7)">Mark as Completed</button>
                <div class="result" id="result-tutorial7"></div>
            </div>
            <!-- Tutorial 8 -->
            <div class="tutorial" data-tutorial-id="8">
                <h3>8. Texture Mapping</h3>
                <p>Apply textures to your 3D objects to add realism.</p>
                <pre><code>#include <GL/freeglut.h>
#include <SOIL/SOIL.h>

// Rotation angles
float angleX = 0.0f;
float angleY = 0.0f;

// Texture ID
GLuint texture;

// Display callback
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    // Move back to see the cube
    glTranslatef(0.0f, 0.0f, -5.0f);

    // Rotate the cube
    glRotatef(angleX, 1.0f, 0.0f, 0.0f);
    glRotatef(angleY, 0.0f, 1.0f, 0.0f);

    // Enable texturing
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, texture);

    // Draw textured cube
    glutSolidCube(2.0f);

    glDisable(GL_TEXTURE_2D);

    glutSwapBuffers();
}

// Idle callback for animation
void idle() {
    angleX += 0.3f;
    angleY += 0.2f;
    if (angleX > 360.0f)
        angleX -= 360.0f;
    if (angleY > 360.0f)
        angleY -= 360.0f;
    glutPostRedisplay();
}

// Initialize OpenGL settings
void initGL() {
    glEnable(GL_DEPTH_TEST);
    glClearColor(0.2f, 0.2f, 0.2f, 1.0f);

    // Load texture
    texture = SOIL_load_OGL_texture(
        "texture.jpg",
        SOIL_LOAD_AUTO,
        SOIL_CREATE_NEW_ID,
        SOIL_FLAG_INVERT_Y
    );

    if(texture == 0) {
        printf("Failed to load texture\n");
    }

    // Texture parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);	
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
}

// Main function
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    // Use double buffering, RGB colors, and depth buffer
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    // Set window size
    glutInitWindowSize(800, 600);
    // Create window with title
    glutCreateWindow("FreeGLUT Texture Mapping");

    initGL();

    // Register callbacks
    glutDisplayFunc(display);
    glutIdleFunc(idle);

    // Enter the main loop
    glutMainLoop();
    return 0;
}</code></pre>
                <button class="btn-submit" onclick="completeTutorial(8)">Mark as Completed</button>
                <div class="result" id="result-tutorial8"></div>
            </div>
            <!-- Add more tutorials as needed -->
        </section>

        <!-- Quizzes Section -->
        <section id="quizzes" class="quizzes">
            <h2>Quizzes</h2>
            <!-- Quiz 1 -->
            <div class="quiz" data-quiz-id="1">
                <h3>Quiz 1: FreeGLUT Basics</h3>
                <p>What is FreeGLUT primarily used for?</p>
                <ul class="options">
                    <li><input type="radio" name="quiz1" id="quiz1a" value="a"><label for="quiz1a">A) Handling network operations</label></li>
                    <li><input type="radio" name="quiz1" id="quiz1b" value="b"><label for="quiz1b">B) Creating windows and handling input in OpenGL applications</label></li>
                    <li><input type="radio" name="quiz1" id="quiz1c" value="c"><label for="quiz1c">C) Database management</label></li>
                    <li><input type="radio" name="quiz1" id="quiz1d" value="d"><label for="quiz1d">D) Image processing</label></li>
                </ul>
                <button class="btn-submit" onclick="submitQuiz(1)">Submit</button>
                <div class="result" id="result-quiz1"></div>
            </div>
            <!-- Quiz 2 -->
            <div class="quiz" data-quiz-id="2">
                <h3>Quiz 2: Code::Blocks Configuration</h3>
                <p>Which library is NOT required to link when setting up FreeGLUT in Code::Blocks?</p>
                <ul class="options">
                    <li><input type="radio" name="quiz2" id="quiz2a" value="a"><label for="quiz2a">A) freeglut.lib</label></li>
                    <li><input type="radio" name="quiz2" id="quiz2b" value="b"><label for="quiz2b">B) opengl32.lib</label></li>
                    <li><input type="radio" name="quiz2" id="quiz2c" value="c"><label for="quiz2c">C) glu32.lib</label></li>
                    <li><input type="radio" name="quiz2" id="quiz2d" value="d"><label for="quiz2d">D) socket.lib</label></li>
                </ul>
                <button class="btn-submit" onclick="submitQuiz(2)">Submit</button>
                <div class="result" id="result-quiz2"></div>
            </div>
            <!-- Quiz 3 -->
            <div class="quiz" data-quiz-id="3">
                <h3>Quiz 3: OpenGL Rendering</h3>
                <p>Which function is used to clear the color and depth buffers in OpenGL?</p>
                <ul class="options">
                    <li><input type="radio" name="quiz3" id="quiz3a" value="a"><label for="quiz3a">A) glClear()</label></li>
                    <li><input type="radio" name="quiz3" id="quiz3b" value="b"><label for="quiz3b">B) glBegin()</label></li>
                    <li><input type="radio" name="quiz3" id="quiz3c" value="c"><label for="quiz3c">C) glEnd()</label></li>
                    <li><input type="radio" name="quiz3" id="quiz3d" value="d"><label for="quiz3d">D) glFlush()</label></li>
                </ul>
                <button class="btn-submit" onclick="submitQuiz(3)">Submit</button>
                <div class="result" id="result-quiz3"></div>
            </div>
            <!-- Quiz 4 -->
            <div class="quiz" data-quiz-id="4">
                <h3>Quiz 4: Input Handling</h3>
                <p>Which callback function handles keyboard input in FreeGLUT?</p>
                <ul class="options">
                    <li><input type="radio" name="quiz4" id="quiz4a" value="a"><label for="quiz4a">A) glutKeyboardFunc()</label></li>
                    <li><input type="radio" name="quiz4" id="quiz4b" value="b"><label for="quiz4b">B) glutMouseFunc()</label></li>
                    <li><input type="radio" name="quiz4" id="quiz4c" value="c"><label for="quiz4c">C) glutDisplayFunc()</label></li>
                    <li><input type="radio" name="quiz4" id="quiz4d" value="d"><label for="quiz4d">D) glutIdleFunc()</label></li>
                </ul>
                <button class="btn-submit" onclick="submitQuiz(4)">Submit</button>
                <div class="result" id="result-quiz4"></div>
            </div>
            <!-- Quiz 5 -->
            <div class="quiz" data-quiz-id="5">
                <h3>Quiz 5: Timer Functions</h3>
                <p>What is the purpose of glutTimerFunc() in FreeGLUT?</p>
                <ul class="options">
                    <li><input type="radio" name="quiz5" id="quiz5a" value="a"><label for="quiz5a">A) To handle keyboard input</label></li>
                    <li><input type="radio" name="quiz5" id="quiz5b" value="b"><label for="quiz5b">B) To create a window</label></li>
                    <li><input type="radio" name="quiz5" id="quiz5c" value="c"><label for="quiz5c">C) To set up a recurring timer callback</label></li>
                    <li><input type="radio" name="quiz5" id="quiz5d" value="d"><label for="quiz5d">D) To draw shapes</label></li>
                </ul>
                <button class="btn-submit" onclick="submitQuiz(5)">Submit</button>
                <div class="result" id="result-quiz5"></div>
            </div>
            <!-- Quiz 6 -->
            <div class="quiz" data-quiz-id="6">
                <h3>Quiz 6: 3D Rendering</h3>
                <p>Which function is used to create a solid cube in FreeGLUT?</p>
                <ul class="options">
                    <li><input type="radio" name="quiz6" id="quiz6a" value="a"><label for="quiz6a">A) glutWireCube()</label></li>
                    <li><input type="radio" name="quiz6" id="quiz6b" value="b"><label for="quiz6b">B) glutSolidCube()</label></li>
                    <li><input type="radio" name="quiz6" id="quiz6c" value="c"><label for="quiz6c">C) glutCube()</label></li>
                    <li><input type="radio" name="quiz6" id="quiz6d" value="d"><label for="quiz6d">D) glutCreateCube()</label></li>
                </ul>
                <button class="btn-submit" onclick="submitQuiz(6)">Submit</button>
                <div class="result" id="result-quiz6"></div>
            </div>
            <!-- Quiz 7 -->
            <div class="quiz" data-quiz-id="7">
                <h3>Quiz 7: Lighting</h3>
                <p>Which function enables lighting in OpenGL?</p>
                <ul class="options">
                    <li><input type="radio" name="quiz7" id="quiz7a" value="a"><label for="quiz7a">A) glEnable(GL_DEPTH_TEST)</label></li>
                    <li><input type="radio" name="quiz7" id="quiz7b" value="b"><label for="quiz7b">B) glEnable(GL_LIGHTING)</label></li>
                    <li><input type="radio" name="quiz7" id="quiz7c" value="c"><label for="quiz7c">C) glEnable(GL_COLOR_MATERIAL)</label></li>
                    <li><input type="radio" name="quiz7" id="quiz7d" value="d"><label for="quiz7d">D) glEnable(GL_TEXTURE_2D)</label></li>
                </ul>
                <button class="btn-submit" onclick="submitQuiz(7)">Submit</button>
                <div class="result" id="result-quiz7"></div>
            </div>
            <!-- Quiz 8 -->
            <div class="quiz" data-quiz-id="8">
                <h3>Quiz 8: Texture Mapping</h3>
                <p>Which library is commonly used to load textures in OpenGL?</p>
                <ul class="options">
                    <li><input type="radio" name="quiz8" id="quiz8a" value="a"><label for="quiz8a">A) SDL</label></li>
                    <li><input type="radio" name="quiz8" id="quiz8b" value="b"><label for="quiz8b">B) GLFW</label></li>
                    <li><input type="radio" name="quiz8" id="quiz8c" value="c"><label for="quiz8c">C) SOIL</label></li>
                    <li><input type="radio" name="quiz8" id="quiz8d" value="d"><label for="quiz8d">D) FreeImage</label></li>
                </ul>
                <button class="btn-submit" onclick="submitQuiz(8)">Submit</button>
                <div class="result" id="result-quiz8"></div>
            </div>
            <!-- Add more quizzes as needed -->
        </section>

        <!-- Code Editor Section -->
        <section id="code-editor" class="code-editor-section">
            <h2>Code Editor</h2>
            <div class="editor-container">
                <textarea id="code-editor-textarea">
// Write your FreeGLUT code here
#include <GL/freeglut.h>

int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutCreateWindow("FreeGLUT Window");
    glutMainLoop();
    return 0;
}
                </textarea>
                <button class="btn-run" onclick="downloadCode()">Download Code</button>
                <div class="output" id="output">
                    <!-- Output or messages will appear here -->
                </div>
            </div>
        </section>

        <!-- 3D Visualization Section -->
        <section id="visualization" class="visualization-section">
            <h2>3D Visualization</h2>
            <div class="visualization-container">
                <p>Explore a simple 3D rotating cube using WebGL.</p>
                <canvas id="webgl-canvas" width="400" height="400"></canvas>
            </div>
        </section>

        <!-- Progress Tracker Section -->
        <section id="progress" class="progress-tracker">
            <h2>Progress Tracker</h2>
            <div class="progress">
                <p>Tutorials Completed:</p>
                <div class="progress-bar">
                    <div class="progress-bar-inner" id="tutorial-progress" style="width: 0%;">0%</div>
                </div>
                <p>Quizzes Completed:</p>
                <div class="progress-bar">
                    <div class="progress-bar-inner" id="quiz-progress" style="width: 0%;">0%</div>
                </div>
            </div>
        </section>
    </div>

    <!-- Footer -->
    <footer id="footer" class="footer">
        <p>&copy; 2024 FreeGLUT Learn. All rights reserved.</p>
        <div class="social-icons">
            <a href="#" target="_blank"><i class="fab fa-facebook-f"></i></a>
            <a href="#" target="_blank"><i class="fab fa-twitter"></i></a>
            <a href="#" target="_blank"><i class="fab fa-github"></i></a>
            <a href="#" target="_blank"><i class="fab fa-linkedin-in"></i></a>
        </div>
    </footer>

    <!-- JavaScript Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/clike/clike.min.js"></script>
    <!-- WebGL Helper Library -->
    <script>
        // Mobile Navigation Toggle
        const menuToggle = document.querySelector('.menu-toggle');
        const navbar = document.querySelector('.navbar');

        menuToggle.addEventListener('click', () => {
            navbar.classList.toggle('active');
        });

        // Smooth Scroll Function
        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            window.scrollTo({
                top: section.offsetTop - 60,
                behavior: 'smooth'
            });
        }

        // Quiz Submission Function
        function submitQuiz(quizNumber) {
            const quiz = document.querySelector('.quiz[data-quiz-id="' + quizNumber + '"]');
            const selectedOption = quiz.querySelector('input[type="radio"]:checked');
            const resultDiv = document.getElementById('result-quiz' + quizNumber);
            let answer = '';
            switch(quizNumber) {
                case 1:
                    answer = 'b';
                    break;
                case 2:
                    answer = 'd';
                    break;
                case 3:
                    answer = 'a';
                    break;
                case 4:
                    answer = 'a';
                    break;
                case 5:
                    answer = 'c';
                    break;
                case 6:
                    answer = 'b';
                    break;
                case 7:
                    answer = 'b';
                    break;
                case 8:
                    answer = 'c';
                    break;
                // Add more cases as needed
                default:
                    answer = '';
            }

            if (selectedOption) {
                if (selectedOption.value === answer) {
                    resultDiv.innerHTML = '<span style="color: green;">Correct!</span>';
                    updateProgress('quiz');
                } else {
                    resultDiv.innerHTML = '<span style="color: red;">Incorrect. Try again.</span>';
                }
            } else {
                resultDiv.innerHTML = '<span style="color: red;">Please select an option.</span>';
            }
        }

        // Tutorial Completion Function
        function completeTutorial(tutorialNumber) {
            const resultDiv = document.getElementById('result-tutorial' + tutorialNumber);
            resultDiv.innerHTML = '<span style="color: green;">Tutorial Completed!</span>';
            updateProgress('tutorial');
        }

        // Progress Tracker
        let tutorialsCompleted = 0;
        let quizzesCompleted = 0;
        const totalTutorials = document.querySelectorAll('.tutorials .tutorial').length;
        const totalQuizzes = document.querySelectorAll('.quizzes .quiz').length;

        function updateProgress(type) {
            if(type === 'tutorial') {
                tutorialsCompleted = Math.min(tutorialsCompleted + 1, totalTutorials);
                updateProgressBar('tutorial-progress', tutorialsCompleted, totalTutorials);
            } else if(type === 'quiz') {
                quizzesCompleted = Math.min(quizzesCompleted + 1, totalQuizzes);
                updateProgressBar('quiz-progress', quizzesCompleted, totalQuizzes);
            }
        }

        function updateProgressBar(elementId, completed, total) {
            const progressPercentage = Math.min((completed / total) * 100, 100);
            const progressBar = document.getElementById(elementId);
            progressBar.style.width = `${progressPercentage}%`;
            progressBar.textContent = `${Math.round(progressPercentage)}%`;
        }

        // Initialize Progress Tracker
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize progress bars
            updateProgressBar('tutorial-progress', tutorialsCompleted, totalTutorials);
            updateProgressBar('quiz-progress', quizzesCompleted, totalQuizzes);

            // Initialize CodeMirror
            const editor = CodeMirror.fromTextArea(document.getElementById('code-editor-textarea'), {
                lineNumbers: true,
                mode: "text/x-c++src",
                theme: "dracula",
                tabSize: 4,
                indentWithTabs: true,
                lineWrapping: true
            });
            window.codeMirrorInstance = editor;
        });

        // Code Editor Download Function
        function downloadCode() {
            const code = window.codeMirrorInstance.getValue();
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'main.cpp';
            a.click();
            URL.revokeObjectURL(url);
            const output = document.getElementById('output');
            output.innerHTML = '<span style="color: green;">Code downloaded successfully!</span>';
            // Optionally mark tutorial as completed
        }

        // WebGL Visualization
        function initWebGL() {
            const canvas = document.getElementById('webgl-canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                alert('WebGL not supported, falling back on experimental-webgl');
                return;
            }

            if (!gl) {
                alert('Your browser does not support WebGL');
                return;
            }

            // Vertex shader program
            const vsSource = `
                attribute vec4 aVertexPosition;
                attribute vec4 aVertexColor;

                uniform mat4 uModelViewMatrix;
                uniform mat4 uProjectionMatrix;

                varying lowp vec4 vColor;

                void main(void) {
                    gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                    vColor = aVertexColor;
                }
            `;

            // Fragment shader program
            const fsSource = `
                varying lowp vec4 vColor;

                void main(void) {
                    gl_FragColor = vColor;
                }
            `;

            // Initialize shader program
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            // Collect shader info
            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                    vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor'),
                },
                uniformLocations: {
                    projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                    modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                },
            };

            // Here's where we call the routine that builds all the objects we'll be drawing.
            const buffers = initBuffers(gl);

            let then = 0;

            // Draw the scene repeatedly
            function render(now) {
                now *= 0.001;  // convert to seconds
                const deltaTime = now - then;
                then = now;

                drawScene(gl, programInfo, buffers, deltaTime);

                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        // Initialize buffers
        function initBuffers(gl) {
            // Create a buffer for the cube's vertex positions.
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Define the positions for a cube
            const positions = [
                // Front face
                -1.0, -1.0,  1.0,
                 1.0, -1.0,  1.0,
                 1.0,  1.0,  1.0,
                -1.0,  1.0,  1.0,

                // Back face
                -1.0, -1.0, -1.0,
                -1.0,  1.0, -1.0,
                 1.0,  1.0, -1.0,
                 1.0, -1.0, -1.0,

                // Top face
                -1.0,  1.0, -1.0,
                -1.0,  1.0,  1.0,
                 1.0,  1.0,  1.0,
                 1.0,  1.0, -1.0,

                // Bottom face
                -1.0, -1.0, -1.0,
                 1.0, -1.0, -1.0,
                 1.0, -1.0,  1.0,
                -1.0, -1.0,  1.0,

                // Right face
                 1.0, -1.0, -1.0,
                 1.0,  1.0, -1.0,
                 1.0,  1.0,  1.0,
                 1.0, -1.0,  1.0,

                // Left face
                -1.0, -1.0, -1.0,
                -1.0, -1.0,  1.0,
                -1.0,  1.0,  1.0,
                -1.0,  1.0, -1.0,
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            // Set up the colors for the faces. We'll use solid colors for each face.
            const faceColors = [
                [1.0, 0.0, 0.0, 1.0],    // Front face: red
                [0.0, 1.0, 0.0, 1.0],    // Back face: green
                [0.0, 0.0, 1.0, 1.0],    // Top face: blue
                [1.0, 1.0, 0.0, 1.0],    // Bottom face: yellow
                [1.0, 0.0, 1.0, 1.0],    // Right face: purple
                [0.0, 1.0, 1.0, 1.0],    // Left face: cyan
            ];

            // Convert the array of colors into a table for all the vertices.
            let colors = [];

            for (let j = 0; j < faceColors.length; ++j) {
                const c = faceColors[j];

                // Repeat each color four times for the four vertices of the face
                colors = colors.concat(c, c, c, c);
            }

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            // Build the element array buffer; this specifies the indices into the vertex arrays for each face's vertices.
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

            // This array defines each face as two triangles, using the indices into the vertex array to specify each triangle's position.
            const indices = [
                0,  1,  2,      0,  2,  3,    // front
                4,  5,  6,      4,  6,  7,    // back
                8,  9, 10,      8, 10, 11,    // top
                12, 13, 14,     12, 14, 15,   // bottom
                16, 17, 18,     16, 18, 19,   // right
                20, 21, 22,     20, 22, 23,   // left
            ];

            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(indices), gl.STATIC_DRAW);

            return {
                position: positionBuffer,
                color: colorBuffer,
                indices: indexBuffer,
            };
        }

        // Initialize shader program
        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

            // Create the shader program
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            // If creating the shader program failed, alert
            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }

            return shaderProgram;
        }

        // Creates a shader of the given type, uploads the source and compiles it.
        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);

            // Send the source to the shader object
            gl.shaderSource(shader, source);

            // Compile the shader program
            gl.compileShader(shader);

            // See if it compiled successfully
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        // Draw the scene.
        let cubeRotation = 0.0;

        function drawScene(gl, programInfo, buffers, deltaTime) {
            gl.clearColor(0.1, 0.1, 0.1, 1.0);  // Clear to black, fully opaque
            gl.clearDepth(1.0);                 // Clear everything
            gl.enable(gl.DEPTH_TEST);           // Enable depth testing
            gl.depthFunc(gl.LEQUAL);            // Near things obscure far things

            // Clear the canvas before we start drawing on it.
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Create a perspective matrix
            const fieldOfView = 45 * Math.PI / 180;   // in radians
            const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
            const zNear = 0.1;
            const zFar = 100.0;
            const projectionMatrix = mat4.create();

            // Note: glmatrix.js always has the first argument as the destination to receive the result.
            mat4.perspective(projectionMatrix,
                             fieldOfView,
                             aspect,
                             zNear,
                             zFar);

            // Set the drawing position to the "identity" point, which is the center of the scene.
            const modelViewMatrix = mat4.create();

            // Move the drawing position a bit to where we want to start drawing the square.
            mat4.translate(modelViewMatrix,     // destination matrix
                           modelViewMatrix,     // matrix to translate
                           [0.0, 0.0, -6.0]);  // amount to translate
            mat4.rotate(modelViewMatrix,  // destination matrix
                        modelViewMatrix,  // matrix to rotate
                        cubeRotation,     // amount to rotate in radians
                        [0, 0, 1]);       // axis to rotate around (Z)
            mat4.rotate(modelViewMatrix,  // destination matrix
                        modelViewMatrix,  // matrix to rotate
                        cubeRotation * .7,// amount to rotate in radians
                        [0, 1, 0]);       // axis to rotate around (Y)

            // Tell WebGL how to pull out the positions from the position buffer into the vertexPosition attribute.
            {
                const numComponents = 3;
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexPosition,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexPosition);
            }

            // Tell WebGL how to pull out the colors from the color buffer into the vertexColor attribute.
            {
                const numComponents = 4;
                const type = gl.FLOAT;
                const normalize = false;
                const stride = 0;
                const offset = 0;
                gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
                gl.vertexAttribPointer(
                    programInfo.attribLocations.vertexColor,
                    numComponents,
                    type,
                    normalize,
                    stride,
                    offset);
                gl.enableVertexAttribArray(
                    programInfo.attribLocations.vertexColor);
            }

            // Tell WebGL which indices to use to index the vertices
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);

            // Tell WebGL to use our program when drawing
            gl.useProgram(programInfo.program);

            // Set the shader uniforms
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.projectionMatrix,
                false,
                projectionMatrix);
            gl.uniformMatrix4fv(
                programInfo.uniformLocations.modelViewMatrix,
                false,
                modelViewMatrix);

            {
                const vertexCount = 36;
                const type = gl.UNSIGNED_SHORT;
                const offset = 0;
                gl.drawElements(gl.TRIANGLES, vertexCount, type, offset);
            }

            // Update the rotation for the next draw
            cubeRotation += deltaTime;
        }

        // Simple matrix library for transformations
        const mat4 = {
            create: function() {
                return new Float32Array([1, 0, 0, 0,
                                         0, 1, 0, 0,
                                         0, 0, 1, 0,
                                         0, 0, 0, 1]);
            },
            perspective: function(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) * nf;
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) * nf;
                out[15] = 0;
                return out;
            },
            translate: function(out, a, v) {
                let x = v[0], y = v[1], z = v[2];
                if (a === out) {
                    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
                } else {
                    let a00, a01, a02, a03;
                    let a10, a11, a12, a13;
                    let a20, a21, a22, a23;

                    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
                    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
                    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

                    out[0] = a00;
                    out[1] = a01;
                    out[2] = a02;
                    out[3] = a03;
                    out[4] = a10;
                    out[5] = a11;
                    out[6] = a12;
                    out[7] = a13;
                    out[8] = a20;
                    out[9] = a21;
                    out[10] = a22;
                    out[11] = a23;

                    out[12] = a00 * x + a10 * y + a20 * z + a[12];
                    out[13] = a01 * x + a11 * y + a21 * z + a[13];
                    out[14] = a02 * x + a12 * y + a22 * z + a[14];
                    out[15] = a03 * x + a13 * y + a23 * z + a[15];
                }

                return out;
            },
            rotate: function(out, a, rad, axis) {
                let x = axis[0], y = axis[1], z = axis[2];
                let len = Math.hypot(x, y, z);
                if (len < 0.000001) { return null; }

                len = 1 / len;
                x *= len;
                y *= len;
                z *= len;

                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const t = 1 - c;

                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];

                // Construct the elements of the rotation matrix
                const b00 = x * x * t + c,     b01 = y * x * t + z * s, b02 = z * x * t - y * s;
                const b10 = x * y * t - z * s, b11 = y * y * t + c,     b12 = z * y * t + x * s;
                const b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;

                // Perform rotation-specific matrix multiplication
                out[0] = a00 * b00 + a10 * b01 + a20 * b02;
                out[1] = a01 * b00 + a11 * b01 + a21 * b02;
                out[2] = a02 * b00 + a12 * b01 + a22 * b02;
                out[3] = a03 * b00 + a13 * b01 + a23 * b02;
                out[4] = a00 * b10 + a10 * b11 + a20 * b12;
                out[5] = a01 * b10 + a11 * b11 + a21 * b12;
                out[6] = a02 * b10 + a12 * b11 + a22 * b12;
                out[7] = a03 * b10 + a13 * b11 + a23 * b12;
                out[8] = a00 * b20 + a10 * b21 + a20 * b22;
                out[9] = a01 * b20 + a11 * b21 + a21 * b22;
                out[10] = a02 * b20 + a12 * b21 + a22 * b22;
                out[11] = a03 * b20 + a13 * b21 + a23 * b22;

                // No perspective component
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
                return out;
            }
        };

        // WebGL Initialization
        window.onload = function() {
            initWebGL();
        };
    </script>
</body>
</html>
